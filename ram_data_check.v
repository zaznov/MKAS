//---------------------------------!
// Это схема контроля данных ОЗУ   !
// (ram_data_check) для платы МКДС !
//---------------------------------!
//      версия от 2020-09-09       !
//---------------------------------!

//= ram_data_check ==============================!
//                                               !
// ЭТО ГОЛОВНОЙ ПО ИЕРАРХИИ МОДУЛЬ ПРОжЕКТА      !
// он состоит из:                                !
//                                               !
// - my_ram_data_check - комбинационная схема    !
// на 4 разряда, вычисляющая число несовпадений  !
// по входам x1_4_in и x2_4_in (2 шт.);          !
// - сумматор ошибок;                            !
// - ram_err_reg - регистр числа ошибок ОЗУ.     !
//                                               !
//===============================================!

module  ram_data_check (x1_in, x2_in, wr_err_reg, all_clear, err_count);

    input   [7:0] x1_in;           // считанные данные с шины данных ОЗУ
    input   [7:0] x2_in;           // младший байт адреса ОЗУ => если нет ошибок, то x1_in = x2_in
    input   wr_err_reg;            // строб записи в регистр числа ошибок (от ram_control_unit)
    input   all_clear;             // общий сброс (от SPI)
    output  [15:0] err_count;      // общее число битовых ошибок (на SPI)
    
    wire    [3:0] err_in_byte;     // число несовпадений
    wire    [3:0] n_err4_out1;     // выходы 1-й 4-х разр. половинки комбинационнгой схемы
    wire    [3:0] n_err4_out2;     // выходы 2-й 4-х разр. половинки комбинационнгой схемы



//+++++++++++++++++++++++++++++++++!
// МЕЖСОЕДИНЕНИЯ ВХОДЯЩИХ МОДУЛЕЙ  !
//+++++++++++++++++++++++++++++++++!

// Первая  4-х разр. половинка  8-р комбинационной схемы

// !------------!   !----------!
// ! имя приме- !   !   имя    !
// !  ненного   !   ! текущего !
// !  модуля    !   !  модуля  !
// !------------!   !----------!
//      !               !
//     \!/             \!/
//      !
    my_ram_data_check   ram_data_check_1_4  // 4-разр. комбинационная схема № 1
    (
// !-------------! !--------!
// !   сигнал    ! !сигнал  !
// ! примененного! !текущего!
// ! модуля      ! !модуля  !
// !-------------! !--------!
//   !          _______!
//   !         !
//  \!/       \!/
//   !         !
.x1_4_in    ({x1_in[3], x1_in[2], x1_in[1], x1_in[0]}),
.x2_4_in    (x2_in[3:0]),
.n_err4_out (n_err4_out1)
    );
      
// Вторая  4-х разр. половинка 8-р комбинационной схемы

// !------------!   !----------!
// ! имя приме- !   !   имя    !
// !  ненного   !   ! текущего !
// !  модуля    !   !  модуля  !
// !------------!   !----------!
//      !               !
//     \!/             \!/
//      !               !
    my_ram_data_check   ram_data_check_2_4  // 4-разр. комбинационная схема № 2
    (
// !-------------! !--------!
// ! сигнал      ! !сигнал  !
// ! примененного! !текущего!
// ! модуля      ! !модуля  !
// !-------------! !--------!
//   !          _______!
//   !         !
//  \!/       \!/
//   !         !
.x1_4_in    (x1_in[7:4]),
.x2_4_in    (x2_in[7:4]),
.n_err4_out (n_err4_out2)
    );
    
// Сумматор ошибок
    assign  err_in_byte = (n_err4_out1 + n_err4_out2);

// Регистр числа ошибок ОЗУ
// !------------! !----------!
// ! имя приме- ! !   имя    !
// ! ненного    ! ! текущего !
// ! модуля     ! !  модуля  !
// !------------! !----------!
//      !               !
//     \!/             \!/
//      !               !
    my_ram_err_reg  ram_err_reg
    (
// !-------------! !--------!
// ! сигнал      ! !сигнал  !
// ! примененного! !текущего!
// ! модуля      ! !модуля  !
// !-------------! !--------!
//   !                 !
//   !                 !----!
//  \!/                    \!/
//   !                      !
    .my_err_in_byte     (err_in_byte),
    .err_reg_clk        (wr_err_reg),
    .err_reg_clr        (all_clear),
    .my_err_reg         (err_count)
    ); 
endmodule


//==============================!
// Описание входящих модулей,   !
// используемыех в проекте      !
//==============================!

//- my_ram_data_check ------------!
// 4-х разрядная схема контроля   !
// данных ОЗУ. Считает число      !
// несовпадений в двух полубайтах !
//--------------------------------!

module my_ram_data_check (x1_4_in, x2_4_in, n_err4_out);
    input       [3:0] x1_4_in;      // входы 1
    input       [3:0] x2_4_in;      // входы 2
    output reg  [2:0] n_err4_out;   // число несовпадений
    wire    [3:0] x1_neq_x2;        // выходы XOR

    // выявление несовпадающих разрядов
    assign  x1_neq_x2   = x1_4_in ^ x2_4_in;    // несовпадающие разряды = 1
 
    // подсчет числа несовпадающих бит в 4-р слове
    // вариант с case   
    always @ (x1_neq_x2)
    begin
    case (x1_neq_x2)
        4'b0000:    n_err4_out	= 0;
        4'b0001:    n_err4_out  = 1;
        4'b0010:    n_err4_out  = 1;
        4'b0011:    n_err4_out  = 2;
        4'b0100:    n_err4_out  = 1;
        4'b0101:    n_err4_out  = 2;
        4'b0110:    n_err4_out  = 2;
        4'b0111:    n_err4_out  = 3;
        4'b1000:    n_err4_out  = 1;
        4'b1001:    n_err4_out  = 2;
        4'b1010:    n_err4_out  = 2;
        4'b1011:    n_err4_out  = 3;
        4'b1100:    n_err4_out  = 2;
        4'b1101:    n_err4_out  = 3;
        4'b1110:    n_err4_out  = 3;
        4'b1111:    n_err4_out  = 4;
        default:    n_err4_out  = 0;
    endcase
    end
endmodule
 
//====================================================  
// то же самое, но вариант с if (похуже)
    /*always @ (*)
    begin
        if      (x1_neq_x2 == 4'b0000)  n_err4_out = 0;
        else if (x1_neq_x2 == 4'b0001)  n_err4_out = 1;
        else if (x1_neq_x2 == 4'b0010)	n_err4_out = 1;
        else if (x1_neq_x2 == 4'b0011)  n_err4_out = 2;
        else if (x1_neq_x2 == 4'b0100)	n_err4_out = 1;
        else if (x1_neq_x2 == 4'b0101)  n_err4_out = 2;
        else if (x1_neq_x2 == 4'b0110)	n_err4_out = 2;
        else if (x1_neq_x2 == 4'b0111)  n_err4_out = 3;
        else if (x1_neq_x2 == 4'b1000)	n_err4_out = 1;
        else if (x1_neq_x2 == 4'b1001)  n_err4_out = 2;
        else if (x1_neq_x2 == 4'b1010)	n_err4_out = 2;
        else if (x1_neq_x2 == 4'b1011)  n_err4_out = 3;
        else if (x1_neq_x2 == 4'b1100)	n_err4_out = 2;
        else if (x1_neq_x2 == 4'b1101)  n_err4_out = 3;
        else if (x1_neq_x2 == 4'b1110)	n_err4_out = 3;
        else if (x1_neq_x2 == 4'b1111)  n_err4_out = 4;
        else    n_err4_out = 0;
    end */
//====================================================

//- my_ram_err_reg -------------------!
// регистр числа ошибок               !
// (фактически накапливающий сумматор)!
//------------------------------------!

module my_ram_err_reg (my_err_in_byte, err_reg_clk, err_reg_clr, my_err_reg);
    // Входы
    input   [7:0] my_err_in_byte;   // входы от ram_data_check
    input   err_reg_clk;            // тактирование
    input   err_reg_clr;            // асинхронный сброс
    // Выходы
    output reg  [15:0] my_err_reg;  // выходы данных

    always @ (posedge err_reg_clr or posedge err_reg_clk)
        begin
            if (err_reg_clr)
            begin
            my_err_reg <= 0;        //асинхронный сброс
            end
            else
            begin
            my_err_reg <= my_err_reg + my_err_in_byte; // суммирование ошибок
            end
        end
endmodule
